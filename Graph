#include <bits/stdc++.h>

// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>

using namespace std;

// using namespace std;
// using namespace __gnu_pbds;

#define int long long 
// #define ll long long
#define endl "\n"
#define pb push_back
#define poop pop_back
#define vil vector<long long int>
#define vii vector<int>
#define vip vector<pair<int,int>>
#define p_count __builtin_popcount
#define all(x) x.begin(),x.end()
#define L lower_bound
#define U upper_bound
#define F first
#define S second
#define mx_e(v) *max_element(all(v))
#define mn_e(v) *min_element(all(v))
#define rep(i,n) for(int i=0;i<n;i++)
#define w(t) cin>>t; while(t--)
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d) min(a,min(b,min(c,d)))

//typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
// nth element *A.find_by_order(n)
// Lower bound *A.lower_bound(n) *A.upper_bound(n)
// Erase *A.erase(n)
// No. of elements smaller than n-> A.order_of_key(n)


#define inf 1e18



/*--------------------------Code----------------------------------------------------------------------------------------*/

const int N=1e5;
vector<int> g[N];
bool vis[N];
void dfs(int source){
	vis[source]=1;
	cout<<source<<' ';
	for(int it : g[source]){
		if(!vis[it]){
			dfs(it);
		}
	}
}

void bfs(int source){
	vis[source]=1;
	queue<int> q;
	q.push(source);
	while(!q.empty()){
		int it=q.front();
		q.pop();
		cout<<it<<' ';
		for(int i : g[it]){
			if(!vis[i]){
				q.push(i);
				vis[i]=1;
			}
		}
	}
}

int32_t main(){
	int n,e;
	cin>>n>>e;
	rep(i,e){
		int x,y;
		cin>>x>>y;
		g[x].pb(y);
		g[y].pb(x);
	}
	bfs(1);
}
